# 数据结构



## 算法

### 图

#### 最短路径

##### dijkstra

**在图中寻找一个节点（称为“源节点”）到所有其它节点的最短路径**，生成一个最短路径树。

![image-20231002230709895](E:\github\clone\c_primer_plus_notes\img\image-20231002230709895.png)

1. **初始化**：首先，选择一个起始节点（源节点），并将该节点的距离设置为0，表示从起始节点到它自身的距离为0。将所有其他节点的距离初始化为无穷大（或一个足够大的值）。
2. **确定最短路径**：从起始节点开始，计算到每个相邻节点的距离。相邻节点是指可以通过一条边直接到达的节点。更新这些相邻节点的距离，如果通过当前节点到达它们的距离比之前计算的距离更短。
3. **选择最短距离节点**：从未选择的节点中选择距离最短的节点作为下一个中间节点。将其标记为已选择。

```c++
#include <iostream>
#include <vector>
#include <limits>

const int INF = std::numeric_limits<int>::max();

// 使用邻接矩阵表示的图
std::vector<std::vector<int>> graph;

// 找到未选择节点中距离最短的节点
int findMinDistance(const std::vector<int>& distance, const std::vector<bool>& visited) {
    int minDistance = INF;
    int minIndex = -1;

    for (int i = 0; i < distance.size(); ++i) {
        if (!visited[i] && distance[i] < minDistance) {
            minDistance = distance[i];
            minIndex = i;
        }
    }

    return minIndex;
}

// 打印最短路径
void printShortestPath(const std::vector<int>& parent, int target) {
    if (parent[target] == -1) {
        std::cout << target << " ";
        return;
    }

    printShortestPath(parent, parent[target]);
    std::cout << target << " ";
}

// 使用Dijkstra算法找到从起始节点到目标节点的最短路径
void dijkstra(int start, int target) {
    int numNodes = graph.size();
    std::vector<int> distance(numNodes, INF);
    std::vector<bool> visited(numNodes, false);
    std::vector<int> parent(numNodes, -1);

    distance[start] = 0;

    for (int i = 0; i < numNodes - 1; ++i) {
        int u = findMinDistance(distance, visited);
        visited[u] = true;
        for (int v = 0; v < numNodes; ++v) {
            if (!visited[v] && graph[u][v] && distance[u] != INF && distance[u] + graph[u][v] < distance[v]) {
                distance[v] = distance[u] + graph[u][v];
                parent[v] = u;
            }
        }
    }

    std::cout << "Shortest Path from " << start << " to " << target << ": ";
    printShortestPath(parent, target);
    std::cout << "\nShortest Distance: " << distance[target] << std::endl;
}

int main() {
    // 例子中的图的邻接矩阵表示
    graph = {
        {0, 5, 0, 3, 0, 0},
        {0, 0, 0, 2, 0, 0},
        {0, 0, 0, 0, 1, 0},
        {0, 0, 0, 0, 4, 2},
        {0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0}
    };

    int startNode = 0; // 起始节点
    int targetNode = 5; // 目标节点

    dijkstra(startNode, targetNode);

    return 0;
}
```





##### floyd

```c++
#include <iostream>
#include <vector>

const int INF = std::numeric_limits<int>::max();

// 使用邻接矩阵表示的图
std::vector<std::vector<int>> graph;

// 使用Floyd-Warshall算法找到所有节点对之间的最短路径
void floydWarshall() {
    int numNodes = graph.size();

    // 创建一个二维数组来存储最短路径距离
    std::vector<std::vector<int>> dist(numNodes, std::vector<int>(numNodes));

    // 初始化距离矩阵
    for (int i = 0; i < numNodes; ++i) {
        for (int j = 0; j < numNodes; ++j) {
            dist[i][j] = graph[i][j];
        }
    }

    // 通过遍历中间节点来更新最短路径
    for (int k = 0; k < numNodes; ++k) {
        for (int i = 0; i < numNodes; ++i) {
            for (int j = 0; j < numNodes; ++j) {
                // 如果通过中间节点k可以获得更短的路径，则更新距离矩阵
                if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }

    // 打印最短路径矩阵
    for (int i = 0; i < numNodes; ++i) {
        for (int j = 0; j < numNodes; ++j) {
            if (dist[i][j] == INF) {
                std::cout << "INF ";
            } else {
                std::cout << dist[i][j] << " ";
            }
        }
        std::cout << std::endl;
    }
}

int main() {
    // 例子中的图的邻接矩阵表示
    graph = {
        {0, 5, INF, 3},
        {INF, 0, 2, INF},
        {INF, INF, 0, 7},
        {2, INF, INF, 0}
    };

    floydWarshall();

    return 0;
}

```





##### 贝尔曼-福特算法

## **示例(Example)**

![img](https://pic1.zhimg.com/80/v2-3253617aa1280adbe911e9fae4133584_720w.webp)

![img](https://pic4.zhimg.com/80/v2-b79ce7e33dcee4a3e915bd1d1d2866e7_720w.webp)

![img](https://pic1.zhimg.com/80/v2-f407fdcc6ac680d357f535258e3f12d8_720w.webp)

![img](https://pic1.zhimg.com/80/v2-0b8efc7f4fcf5d767fc7b678c1d08c8c_720w.webp)

```c++
#include <iostream>
#include <vector>
#include <limits>

const int INF = std::numeric_limits<int>::max();

struct Edge {
    int source;
    int destination;
    int weight;
};

// 使用邻接表表示的图
std::vector<Edge> edges;
int numNodes, numEdges;
std::vector<int> distance;

// 初始化图的边和节点数
void initialize(int nodes, int edgesCount) {
    numNodes = nodes;
    numEdges = edgesCount;
    edges.clear();
    distance.resize(numNodes, INF);
}

// 添加一条有向边到图中
void addEdge(int source, int destination, int weight) {
    Edge edge = {source, destination, weight};
    edges.push_back(edge);
}

// 使用贝尔曼-福特算法找到从源节点到所有其他节点的最短路径
bool bellmanFord(int source) {
    distance[source] = 0;

    // 对所有节点进行V-1次松弛操作
    for (int i = 1; i < numNodes; ++i) {
        for (const Edge& edge : edges) {
            if (distance[edge.source] != INF && distance[edge.source] + edge.weight < distance[edge.destination]) {
                distance[edge.destination] = distance[edge.source] + edge.weight;
            }
        }
    }

    // 检查是否存在负权回路
    for (const Edge& edge : edges) {
        if (distance[edge.source] != INF && distance[edge.source] + edge.weight < distance[edge.destination]) {
            return false; // 存在负权回路
        }
    }

    return true;
}

int main() {
    initialize(5, 8); // 创建一个包含5个节点和8条边的图

    // 添加边
    addEdge(0, 1, -1);
    addEdge(0, 2, 4);
    addEdge(1, 2, 3);
    addEdge(1, 3, 2);
    addEdge(1, 4, 2);
    addEdge(3, 2, 5);
    addEdge(3, 1, 1);
    addEdge(4, 3, -3);

    int sourceNode = 0;

    if (bellmanFord(sourceNode)) {
        std::cout << "从节点 " << sourceNode << " 到其他节点的最短路径距离：" << std::endl;
        for (int i = 0; i < numNodes; ++i) {
            std::cout << "节点 " << i << ": " << distance[i] << std::endl;
        }
    } else {
        std::cout << "图中存在负权回路，无法计算最短路径。" << std::endl;
    }

    return 0;
}

```



##### A*算法

```text
* 初始化open_set和close_set；
* 将起点加入open_set中，并设置优先级为0（优先级最高）；
* 如果open_set不为空，则从open_set中选取优先级最高的节点n：
    * 如果节点n为终点，则：
        * 从终点开始逐步追踪parent节点，一直达到起点；
        * 返回找到的结果路径，算法结束；
    * 如果节点n不是终点，则：
        * 将节点n从open_set中删除，并加入close_set中；
        * 遍历节点n所有的邻近节点：
            * 如果邻近节点m在close_set中，则：
                * 跳过，选取下一个邻近节点
            * 如果邻近节点m也不在open_set中，则：
                * 设置节点m的parent为节点n
                * 计算节点m的优先级
                * 将节点m加入open_set中
```

```c++
#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <cmath>

struct Node {
    int x, y; // 节点的坐标
    int g;    // 从起始节点到当前节点的实际成本
    int h;    // 启发式函数的估算成本
    int f;    // f = g + h，用于确定节点的优先级

    bool operator<(const Node& other) const {
        return f < other.f;
    }
};

// 启发式函数：曼哈顿距离
int heuristic(const Node& current, const Node& goal) {
    return std::abs(current.x - goal.x) + std::abs(current.y - goal.y);
}

// A*算法
std::vector<Node> astar(const std::vector<std::vector<int>>& grid, Node start, Node goal) {
    int rows = grid.size();
    int cols = grid[0].size();
    std::vector<std::vector<bool>> visited(rows, std::vector<bool>(cols, false));
    std::set<Node> openSet;
    std::map<Node, Node> cameFrom;

    start.g = 0;
    start.h = heuristic(start, goal);
    start.f = start.g + start.h;
    openSet.insert(start);

    while (!openSet.empty()) {
        Node current = *openSet.begin();

        if (current.x == goal.x && current.y == goal.y) {
            // 找到路径，回溯构建路径
            std::vector<Node> path;
            while (cameFrom.find(current) != cameFrom.end()) {
                path.push_back(current);
                current = cameFrom[current];
            }
            path.push_back(start);
            std::reverse(path.begin(), path.end());
            return path;
        }

        openSet.erase(openSet.begin());
        visited[current.x][current.y] = true;

        // 遍历相邻节点
        std::vector<Node> neighbors;
        if (current.x > 0) neighbors.push_back({current.x - 1, current.y});
        if (current.x < rows - 1) neighbors.push_back({current.x + 1, current.y});
        if (current.y > 0) neighbors.push_back({current.x, current.y - 1});
        if (current.y < cols - 1) neighbors.push_back({current.x, current.y + 1});

        for (const Node& neighbor : neighbors) {
            if (!visited[neighbor.x][neighbor.y] && grid[neighbor.x][neighbor.y] != 1) {
                int tentativeG = current.g + 1; // 1表示相邻节点之间的实际成本

                if (openSet.find(neighbor) == openSet.end() || tentativeG < neighbor.g) {
                    neighbor.g = tentativeG;
                    neighbor.h = heuristic(neighbor, goal);
                    neighbor.f = neighbor.g + neighbor.h;
                    openSet.insert(neighbor);
                    cameFrom[neighbor] = current;
                }
            }
        }
    }

    return std::vector<Node>(); // 未找到路径
}

int main() {
    // 示例地图，0表示可通过的路径，1表示障碍物
    std::vector<std::vector<int>> grid = {
        {0, 0, 0, 0, 1},
        {0, 1, 1, 0, 0},
        {0, 0, 0, 1, 0},
        {0, 1, 0, 0, 0},
        {0, 0, 0, 0, 0}
    };

    Node start = {0, 0};
    Node goal = {4, 4};

    std::vector<Node> path = astar(grid, start, goal);

    if (!path.empty()) {
        std::cout << "找到最短路径：" << std::endl;
        for (const Node& node : path) {
            std::cout << "(" << node.x << ", " << node.y << ")" << std::endl;
        }
    } else {
        std::cout << "未找到路径。" << std::endl;
    }

    return 0;
}

```

